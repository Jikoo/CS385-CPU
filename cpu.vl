
// Top-level CPU module
module CPU (clock, programCounter, aluResult, instructionReg);
  // Module Inputs
  input clock; // Main system clock signal

  // Module Outputs
  output [15:0] aluResult, instructionReg, programCounter; // ALU output, current instruction, and PC value

  // Internal Registers and Wires
  reg [15:0] programCounter;               // Register to hold the address of the current instruction
  reg [15:0] instructionMemory[0:1023];    // Memory block for storing the program instructions
  wire [3:0] aluControl;                   // Control signals for the ALU operation
  wire [1:0] writeRegAddr;                 // Address of the register to be written to
  wire [15:0] instructionReg, nextPC, regDataA, regDataB, aluResult, regData2, immediateExtended;
  wire writeEnable, unused_zero, isZero, regDestSelect, aluSrcSelect;


  initial begin
    instructionMemory[0] = 16'b0111_00_01_00001111; // addi $t1, $0, 15   ($t1 should be 15)
    instructionMemory[1] = 16'b0111_00_10_00000111; // addi $t2, $0, 7    ($t2 should be 7)
    instructionMemory[2] = 16'b0010_01_10_11_000000; // and  $t3, $t1, $t2  ($t3 should be 7)
    instructionMemory[3] = 16'b0001_01_11_10_000000; // sub  $t2, $t1, $t3  ($t2 should be 8)
    instructionMemory[4] = 16'b0011_10_11_10_000000; // or   $t2, $t2, $t3  ($t2 should be 15)
    instructionMemory[5] = 16'b0000_10_11_11_000000; // add  $t3, $t2, $t3  ($t3 should be 22)
    instructionMemory[6] = 16'b0100_10_11_01_000000; // nor  $t1, $t2, $t3  ($t1 should be -32)
    instructionMemory[7] = 16'b0110_11_10_01_000000; // slt  $t1, $t3, $t2  ($t1 should be 0)
    instructionMemory[8] = 16'b0110_10_11_01_000000; // slt  $t1, $t2, $t3  ($t1 should be 1)
  end

  // Set initial program counter value
  initial programCounter = 0;

  // Instruction Fetch (IF) Stage
  assign instructionReg = instructionMemory[programCounter >> 1]; // Retrieve instruction from memory. PC is byte-addressed, memory is 16-bit word-addressed.

  // Instruction Decode (ID) Stage
  // Mux to select the destination register (rd for R-type, rt for I-type)
  mux_2x2 muxReg (writeRegAddr, {instructionReg[7:6], instructionReg[9:8]}, regDestSelect);
  // Mux to select ALU's second operand (register or sign-extended immediate)
  mux_2x16 muxData (regDataB, {immediateExtended, regData2}, aluSrcSelect);
  assign immediateExtended = {{8{instructionReg[7]}}, instructionReg[7:0]}; // Sign-extend the 8-bit immediate to 16 bits

  // Instantiate CPU Components
  RegisterFile reg_file (instructionReg[11:10], instructionReg[9:8], writeRegAddr, aluResult, writeEnable, regDataA, regData2, clock);
  ALU pc_incrementer (nextPC, unused_zero, ignored, programCounter, 16'd2, 4'b0010); // ALU used to calculate PC + 2
  ALU execution_unit (aluResult, isZero, ignored, regDataA, regDataB, aluControl);    // Main ALU for instruction execution
  MainControl main_control (instructionReg[15:12], {regDestSelect, aluSrcSelect, writeEnable, aluControl}); // Decodes opcode to generate control signals

  // Update Program Counter on the clock's falling edge
  always @(negedge clock) begin
    programCounter <= nextPC; // Move to the next instruction
  end
endmodule

// Main Control Unit
module MainControl (opcode, controlSignals);
  // Inputs
  input [3:0] opcode; // 4-bit instruction opcode
  // Outputs
  output reg [6:0] controlSignals; // Bundled control signals for the datapath

  // Control Signal bits: {regDestSelect, aluSrcSelect, writeEnable, aluControl[3:0]}
  always @(opcode)
    case (opcode)
      // R-type Instructions
      4'b0000: controlSignals = 7'b1_0_1_0010; // add
      4'b0001: controlSignals = 7'b1_0_1_0110; // sub
      4'b0010: controlSignals = 7'b1_0_1_0000; // and
      4'b0011: controlSignals = 7'b1_0_1_0001; // or
      4'b0100: controlSignals = 7'b1_0_1_1100; // nor
      4'b0101: controlSignals = 7'b1_0_1_1101; // nand
      4'b0110: controlSignals = 7'b1_0_1_0111; // slt

      // I-type Instructions
      4'b0111: controlSignals = 7'b0_1_1_0010; // addi
    endcase
endmodule

// Register File
module RegisterFile (readAddr1, readAddr2, writeAddr, writeData, writeEnable, readData1, readData2, clock);
  // Inputs
  input [1:0] readAddr1, readAddr2; // Addresses for reading two registers
  input [1:0] writeAddr;            // Address for writing to a register
  input [15:0] writeData;           // Data to be written
  input writeEnable;                // Control signal to enable writing
  input clock;                      // System clock for synchronous writes

  // Outputs
  output [15:0] readData1, readData2; // Data read from the specified registers

  reg [15:0] registerBank[0:3];     // Array of four 16-bit registers

  // Combinational read logic
  assign readData1 = registerBank[readAddr1];
  assign readData2 = registerBank[readAddr2];

  // Initialize register $0 to be a constant zero
  initial registerBank[0] = 0;

  // Synchronous write logic
  always @(negedge clock)
    if (writeEnable == 1 && writeAddr != 0) // Write only if enabled and not to register $0
      registerBank[writeAddr] <= writeData;
endmodule

// 16-bit Arithmetic Logic Unit
module ALU(r, zero, overflow, a, b, s);
  input [15:0] a, b;
  input [3:0] s;
  output [15:0] r;
  output zero, overflow;

  wire set;
  ALU1   alu0  (r[0],  co0,  a[0],  b[0],  set,  s, s[2]),
         alu1  (r[1],  co1,  a[1],  b[1],  1'b0, s, co0),
         alu2  (r[2],  co2,  a[2],  b[2],  1'b0, s, co1),
         alu3  (r[3],  co3,  a[3],  b[3],  1'b0, s, co2),
         alu4  (r[4],  co4,  a[4],  b[4],  1'b0, s, co3),
         alu5  (r[5],  co5,  a[5],  b[5],  1'b0, s, co4),
         alu6  (r[6],  co6,  a[6],  b[6],  1'b0, s, co5),
         alu7  (r[7],  co7,  a[7],  b[7],  1'b0, s, co6),
         alu8  (r[8],  co8,  a[8],  b[8],  1'b0, s, co7),
         alu9  (r[9],  co9,  a[9],  b[9],  1'b0, s, co8),
         alu10 (r[10], co10, a[10], b[10], 1'b0, s, co9),
         alu11 (r[11], co11, a[11], b[11], 1'b0, s, co10),
         alu12 (r[12], co12, a[12], b[12], 1'b0, s, co11),
         alu13 (r[13], co13, a[13], b[13], 1'b0, s, co12),
         alu14 (r[14], co14, a[14], b[14], 1'b0, s, co13);
  ALUmsb alu15 (r[15], set, overflow, a[15], b[15], 1'b0, s, co14);

  nor no1 (zero, r);
endmodule

// ALU subsection for all bits other than most significant bit
module ALU1(r, co, a, b, less, s, ci);
  input a, b, less, ci;
  input [3:0] s;
  output r, co;

  not n1 (na, a),
      n2 (nb, b);

  mux_2x1 inA (A, {na, a}, s[3]),
          inB (B, {nb, b}, s[2]);

  and a1 (r0, A, B);
  or o1 (r1, A, B);
  fulladder fa1 (co, r2, A, B, ci);

  mux_4x1 s1 (r, {less, r2, r1, r0}, s[1:0]);
endmodule

// ALU subsection for most significant bit
module ALUmsb(r, set, of, a, b, less, s, ci);
  input a, b, less, ci;
  input [3:0] s;
  output r, set, of;

  not n1 (na, a),
      n2 (nb, b);

  mux_2x1 inA (A, {na, a}, s[3]),
          inB (B, {nb, b}, s[2]);

  and a1 (r0, A, B);
  or o1 (r1, A, B);
  fulladder fa1 (co, set, A, B, ci);

  mux_4x1 s1 (r, {less, set, r1, r0}, s[1:0]);

  xor xo1 (of0, ci, co);
  and a3 (of, of0, s[1]);
endmodule

// 2x16 multiplexer
module mux_2x16(out, in, select);
  input [31:0] in;
  input select;
  output [15:0] out;
  mux_2x2 mux0 (out[1:0],   {in[17:16], in[1:0]},   select),
          mux1 (out[3:2],   {in[19:18], in[3:2]},   select),
          mux2 (out[5:4],   {in[21:20], in[5:4]},   select),
          mux3 (out[7:6],   {in[23:22], in[7:6]},   select),
          mux4 (out[9:8],   {in[25:24], in[9:8]},   select),
          mux5 (out[11:10], {in[27:26], in[11:10]}, select),
          mux6 (out[13:12], {in[29:28], in[13:12]}, select),
          mux7 (out[15:14], {in[31:30], in[15:14]}, select);
endmodule

// 2x2 multiplexer
module mux_2x2(out, in, select);
  input [3:0] in;
  input select;
  output [1:0] out;
  mux_2x1 muxLow  (out[0], {in[2], in[0]}, select),
          muxHigh (out[1], {in[3], in[1]}, select);
endmodule

// 2x1 multiplexer
module mux_2x1(out, in, select);
  input [1:0] in;
  input select;
  output out;
  wire a, b, selectprime;
  not n1 (selectprime, select);
  and a1 (a, in[0], selectprime);
  and a2 (b, in[1], select);
  or o1 (out, a, b);
endmodule

// 4x1 multiplexer
module mux_4x1(out, in, select);
  input [3:0] in;
  input [1:0] select;
  output out;

  not n1 (selectprime, select[1]);

  wire [1:0] work;
  mux_2x1 low (work[0], in[1:0], select[0]),
          high (work[1], in[3:2], select[0]),
          comb (out, work, select[1]);
endmodule

// 1-bit full adder
module fulladder(co, s, x, y, ci);
  input x, y, ci;
  output s, co;
  halfadder hadd1 (c1, s1, x, y),
            hadd2 (c2, s, s1, ci);
  or o1 (co, c1, c2);
endmodule

// 1-bit half adder
module halfadder(c, s, x, y);
  input x, y;
  output c, s;
  and a0 (c, x, y);
  not n0 (nc, c);
  or o0 (a, x, y);
  and a1 (s, a, nc);
endmodule

// 16-bit single shift left
module shift_left_1(shifted, in);
  input [15:0] in;
  output [15:0] shifted;
  assign shifted = {in[14:0], 1'b0};
endmodule

// Sign extender converting an 8-bit two's complement number to 16 bits
module sign_extend_8_to_16 (extended, base);
  input [7:0] base;
  output [16:0] extended;
  assign extended = {{8{base[7]}}, base};
endmodule

// Testbench module for the CPU
module CPU_Testbench ();
  reg clock_tb;
  wire signed [15:0] aluResult_tb, instruction_tb, pc_tb;

  // Instantiate the CPU for testing
  CPU cpu_under_test(clock_tb, pc_tb, aluResult_tb, instruction_tb);

  // Generate a clock signal that toggles every 1 time unit
  always #1 clock_tb = ~clock_tb;

  // Simulation control and display
  initial begin
    $display();
    $display ("Clock  PC        Instruction        ALU Result (Decimal & Binary)");
    $monitor ("%b     %2d   %16b    %3d (%16b)", clock_tb, pc_tb, instruction_tb, aluResult_tb, aluResult_tb);
    clock_tb = 1;
    #16; // Run simulation for 16 time units
    $monitoroff;
    $display("\nSimulation complete.");
    $finish;
  end
endmodule
