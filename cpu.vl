module CPU (clock,PC,IFID_IR,IDEX_IR,WD);
  input clock;
  output [15:0] PC,IFID_IR,IDEX_IR,WD;
  
  initial begin
// Program with nop's - no hazards
    IMemory[0]  = 16'b0111_00_01_00001111;  // addi $t1, $0,  15   ($t1=15)
    IMemory[1]  = 16'b0111_00_10_00000111;  // addi $t2, $0,  7    ($t2= 7)
    IMemory[2]  = 16'b0000_00_00_00_000000; // nop
    IMemory[3]  = 16'b0010_01_10_11_000000; // and  $t3, $t1, $t2  ($t3= 7)
    IMemory[4]  = 16'b0000_00_00_00_000000; // nop
    IMemory[5]  = 16'b0001_01_11_10_000000; // sub  $t2, $t1, $t3  ($t2= 8)
    IMemory[6]  = 16'b0000_00_00_00_000000; // nop
    IMemory[7]  = 16'b0011_10_11_10_000000; // or   $t2, $t2, $t3  ($t2=15)
    IMemory[8]  = 16'b0000_00_00_00_000000; // nop
    IMemory[9]  = 16'b0000_10_11_11_000000; // add  $t3, $t2, $t3  ($t3=22)
    IMemory[10] = 16'b0000_00_00_00_000000; // nop
    IMemory[11] = 16'b0100_10_11_01_000000; // nor  $t1, $t2, $t3  ($t1=-32)
    IMemory[12] = 16'b0110_11_10_01_000000; // slt  $t1, $t3, $t2  ($t1= 0)
    IMemory[13] = 16'b0110_10_11_01_000000; // slt  $t1, $t2, $t3  ($t1= 1)
  end
/*
  initial begin 
// Program without nop's - wrong results due to data hazards
    IMemory[0] = 16'b0111_00_01_00001111;  // addi $t1, $0,  15   ($t1=15)
    IMemory[1] = 16'b0111_00_10_00000111;  // addi $t2, $0,  7    ($t2= 7)
    IMemory[2] = 16'b0010_01_10_11_000000; // and  $t3, $t1, $t2  ($t3= 7)
    IMemory[3] = 16'b0001_01_11_10_000000; // sub  $t2, $t1, $t3  ($t2= 8)
    IMemory[4] = 16'b0011_10_11_10_000000; // or   $t2, $t2, $t3  ($t2=15)
    IMemory[5] = 16'b0000_10_11_11_000000; // add  $t3, $t2, $t3  ($t3=22)
    IMemory[6] = 16'b0100_10_11_01_000000; // nor  $t1, $t2, $t3  ($t1=-32)
    IMemory[7] = 16'b0110_11_10_01_000000; // slt  $t1, $t3, $t2  ($t1= 0)
    IMemory[8] = 16'b0110_10_11_01_000000; // slt  $t1, $t2, $t3  ($t1= 1)
  end
*/
// Pipeline stages
//=== IF STAGE ===
  wire [15:0] NextPC;
  reg[15:0] PC, IMemory[0:1023];
  ALU fetch (NextPC, ignored, ignored, PC, 16'd2, 4'b0010);

//--------------------------------
  reg[15:0] IFID_IR;
//--------------------------------

//=== ID STAGE ===
  wire [6:0] Control;
  wire [15:0] RD1,RD2,SignExtend,WD;
  wire [15:0] FWD_RD1,FWD_RD2; // Outputs of the forwarding muxes
  wire [1:0] WR;
  RegisterFile rf (IFID_IR[11:10],IFID_IR[9:8],WR,WD,IDEX_RegWrite,RD1,RD2,clock);
  MainControl MainCtr (IFID_IR[15:12],Control);
  assign SignExtend = {{8{IFID_IR[7]}},IFID_IR[7:0]}; // sign extension

//--------------------------------
  reg [15:0] IDEX_IR; // For monitoring the pipeline
  reg IDEX_RegWrite,IDEX_ALUSrc,IDEX_RegDst;
  reg [3:0]  IDEX_ALUctl;
  reg [15:0] IDEX_RD1,IDEX_RD2,IDEX_SignExt;
  reg [1:0]  IDEX_rt,IDEX_rd;
//--------------------------------

//=== EXE STAGE ===
  wire [15:0] B,ALUOut;
  ALU execution_unit (ALUOut, ignored, ignored, IDEX_RD1, B, IDEX_ALUctl);
  // ALUSrc Mux 
  mux_2x16 muxData (B, {IDEX_SignExt, IDEX_RD2}, IDEX_ALUSrc);
  // RegDst Mux
  mux_2x2 muxReg (WR, {IDEX_rd, IDEX_rt}, IDEX_RegDst);
  assign WD = ALUOut; // TODO is there a point to this?

// Forwarding multiplexers
  // TODO gate-level
  assign FWD_RD1 = (IDEX_RegWrite && WR==IFID_IR[11:10]) ? ALUOut: RD1;
  assign FWD_RD2 = (IDEX_RegWrite && WR==IFID_IR[9:8]) ? ALUOut: RD2;

  initial begin
    PC = 0;
    IFID_IR = 0; // clear pipeline register to avoid forwarding from empty pipeline
    IDEX_RegWrite = 0; 
  end

// Running the pipeline
  always @(negedge clock) begin

// Stage 1 - IF
    PC <= NextPC;
    IFID_IR <= IMemory[PC>>1];

// Stage 2 - ID
    IDEX_IR <= IFID_IR; // For monitoring the pipeline
    {IDEX_RegDst,IDEX_ALUSrc,IDEX_RegWrite,IDEX_ALUctl} <= Control;    

//  No Forwarding
//    IDEX_RD1 <= RD1; 
//    IDEX_RD2 <= RD2;

//  Forwarding
    IDEX_RD1 <= FWD_RD1; 
    IDEX_RD2 <= FWD_RD2;

    IDEX_SignExt <= SignExtend;
    IDEX_rt <= IFID_IR[9:8];
    IDEX_rd <= IFID_IR[7:6];

// Stage 3 - EX
// No transfers needed here - on negedge WD is written into register WR
  end
endmodule


// Main Control Unit
module MainControl (Op, Control);
  // Inputs:
  input [3:0] Op;  // 4-bit opcode from instruction field

  // Outputs:
  output reg [6:0] Control; // Control signals for CPU execution
  // Format: {RegDst,ALUSrc,RegWrite,ALUctl[3:0]}

  always @(Op)
    case (Op)
      // R-type Instructions
      4'b0000: Control = 7'b1_0_1_0010; // add
      4'b0001: Control = 7'b1_0_1_0110; // sub
      4'b0010: Control = 7'b1_0_1_0000; // and
      4'b0011: Control = 7'b1_0_1_0001; // or
      4'b0100: Control = 7'b1_0_1_1100; // nor
      4'b0101: Control = 7'b1_0_1_1101; // nand
      4'b0110: Control = 7'b1_0_1_0111; // slt

      // I-type Instructions
      4'b0111: Control = 7'b0_1_1_0010; // addi
    endcase
endmodule

// Branch Control Unit
module BranchControl (BranchTaken, BEQ, BNE, Zero);
  output BranchTaken;
  input BEQ, BNE, Zero;

  not n1 (NotZero, Zero);
  and a1 (BeqTaken, BEQ, Zero);
  and a2 (BneTaken, BNE, NotZero);
  or o1 (BranchTaken, BeqTaken, BneTaken);
endmodule

// Register File
module RegisterFile (readAddr1, readAddr2, writeAddr, writeData, writeEnable, readData1, readData2, clock);
  // Inputs
  input [1:0] readAddr1, readAddr2; // Addresses for reading two registers
  input [1:0] writeAddr;            // Address for writing to a register
  input [15:0] writeData;           // Data to be written
  input writeEnable;                // Control signal to enable writing
  input clock;                      // System clock for synchronous writes

  // Outputs
  output [15:0] readData1, readData2; // Data read from the specified registers

  reg [15:0] registerBank[0:3];     // Array of four 16-bit registers

  // Combinational read logic
  assign readData1 = registerBank[readAddr1];
  assign readData2 = registerBank[readAddr2];

  // Initialize register $0 to be a constant zero
  initial registerBank[0] = 0;

  // Synchronous write logic
  always @(negedge clock)
    if (writeEnable == 1 && writeAddr != 0) // Write only if enabled and not to register $0
      registerBank[writeAddr] <= writeData;
endmodule

// 16-bit Arithmetic Logic Unit
module ALU(r, zero, overflow, a, b, s);
  input [15:0] a, b;
  input [3:0] s;
  output [15:0] r;
  output zero, overflow;

  wire set;
  ALU1   alu0  (r[0],  co0,  a[0],  b[0],  set,  s, s[2]),
         alu1  (r[1],  co1,  a[1],  b[1],  1'b0, s, co0),
         alu2  (r[2],  co2,  a[2],  b[2],  1'b0, s, co1),
         alu3  (r[3],  co3,  a[3],  b[3],  1'b0, s, co2),
         alu4  (r[4],  co4,  a[4],  b[4],  1'b0, s, co3),
         alu5  (r[5],  co5,  a[5],  b[5],  1'b0, s, co4),
         alu6  (r[6],  co6,  a[6],  b[6],  1'b0, s, co5),
         alu7  (r[7],  co7,  a[7],  b[7],  1'b0, s, co6),
         alu8  (r[8],  co8,  a[8],  b[8],  1'b0, s, co7),
         alu9  (r[9],  co9,  a[9],  b[9],  1'b0, s, co8),
         alu10 (r[10], co10, a[10], b[10], 1'b0, s, co9),
         alu11 (r[11], co11, a[11], b[11], 1'b0, s, co10),
         alu12 (r[12], co12, a[12], b[12], 1'b0, s, co11),
         alu13 (r[13], co13, a[13], b[13], 1'b0, s, co12),
         alu14 (r[14], co14, a[14], b[14], 1'b0, s, co13);
  ALUmsb alu15 (r[15], set, overflow, a[15], b[15], 1'b0, s, co14);

  nor no1 (zero, r);
endmodule

// ALU subsection for all bits other than most significant bit
module ALU1(r, co, a, b, less, s, ci);
  input a, b, less, ci;
  input [3:0] s;
  output r, co;

  not n1 (na, a),
      n2 (nb, b);

  mux_2x1 inA (A, {na, a}, s[3]),
          inB (B, {nb, b}, s[2]);

  and a1 (r0, A, B);
  or o1 (r1, A, B);
  fulladder fa1 (co, r2, A, B, ci);

  mux_4x1 s1 (r, {less, r2, r1, r0}, s[1:0]);
endmodule

// ALU subsection for most significant bit
module ALUmsb(r, set, of, a, b, less, s, ci);
  input a, b, less, ci;
  input [3:0] s;
  output r, set, of;

  not n1 (na, a),
      n2 (nb, b);

  mux_2x1 inA (A, {na, a}, s[3]),
          inB (B, {nb, b}, s[2]);

  and a1 (r0, A, B);
  or o1 (r1, A, B);
  fulladder fa1 (co, set, A, B, ci);

  mux_4x1 s1 (r, {less, set, r1, r0}, s[1:0]);

  xor xo1 (of0, ci, co);
  and a3 (of, of0, s[1]);
endmodule

// 2x16 multiplexer
module mux_2x16(out, in, select);
  input [31:0] in;
  input select;
  output [15:0] out;
  mux_2x2 mux0 (out[1:0],   {in[17:16], in[1:0]},   select),
          mux1 (out[3:2],   {in[19:18], in[3:2]},   select),
          mux2 (out[5:4],   {in[21:20], in[5:4]},   select),
          mux3 (out[7:6],   {in[23:22], in[7:6]},   select),
          mux4 (out[9:8],   {in[25:24], in[9:8]},   select),
          mux5 (out[11:10], {in[27:26], in[11:10]}, select),
          mux6 (out[13:12], {in[29:28], in[13:12]}, select),
          mux7 (out[15:14], {in[31:30], in[15:14]}, select);
endmodule

// 2x2 multiplexer
module mux_2x2(out, in, select);
  input [3:0] in;
  input select;
  output [1:0] out;
  mux_2x1 muxLow  (out[0], {in[2], in[0]}, select),
          muxHigh (out[1], {in[3], in[1]}, select);
endmodule

// 2x1 multiplexer
module mux_2x1(out, in, select);
  input [1:0] in;
  input select;
  output out;
  wire a, b, selectprime;
  not n1 (selectprime, select);
  and a1 (a, in[0], selectprime);
  and a2 (b, in[1], select);
  or o1 (out, a, b);
endmodule

// 4x1 multiplexer
module mux_4x1(out, in, select);
  input [3:0] in;
  input [1:0] select;
  output out;

  not n1 (selectprime, select[1]);

  wire [1:0] work;
  mux_2x1 low (work[0], in[1:0], select[0]),
          high (work[1], in[3:2], select[0]),
          comb (out, work, select[1]);
endmodule

// 1-bit full adder
module fulladder(co, s, x, y, ci);
  input x, y, ci;
  output s, co;
  halfadder hadd1 (c1, s1, x, y),
            hadd2 (c2, s, s1, ci);
  or o1 (co, c1, c2);
endmodule

// 1-bit half adder
module halfadder(c, s, x, y);
  input x, y;
  output c, s;
  and a0 (c, x, y);
  not n0 (nc, c);
  or o0 (a, x, y);
  and a1 (s, a, nc);
endmodule

// Test module
module test ();
  reg clock;
  wire signed [15:0] PC,IFID_IR,IDEX_IR,WD;
  CPU test_cpu(clock,PC,IFID_IR,IDEX_IR,WD);
  always #1 clock = ~clock;
  initial begin
    $display ("PC  IFID_IR   IDEX_IR   WD");
    $monitor ("%2d     %h      %h   %2d",PC,IFID_IR,IDEX_IR,WD);
    clock = 1;
    #29 $finish;
  end
endmodule
