
// Top-level CPU module
module CPU (clock,WD,IR,PC);

  input clock;
  output [15:0] WD,IR,PC;
  reg[15:0] PC, IMemory[0:1023], DMemory[0:1023];
  wire [15:0] IR,SignExtend,NextPC,RD2,A,B,ALUOut,PCplus2,Target;
  wire [1:0] WR;
  wire [3:0] ALUctl;
  wire [1:0] ALUOp;
  initial begin
    // Program: swap memory cells and compute absolute value
    IMemory[0] = 16'b1000_00_01_00000000;  // lw $t1, 0($0)
    IMemory[1] = 16'b1000_00_10_00000010;  // lw $t2, 2($0)
    IMemory[2] = 16'b0110_01_10_11_000000;  // slt $t3, $t1, $t2
    IMemory[3] = 16'b1010_11_00_00000010;  // beq $t3, $0, IMemory[6]
    // IMemory[3] = 16'b1011_11_00_00000010; // bne $t3, $0, IMemory[6]
    IMemory[4] = 16'b1001_00_01_00000010;  // sw $t1, 2($0)
    IMemory[5] = 16'b1001_00_10_00000000;  // sw $t2, 0($0)
    IMemory[6] = 16'b1000_00_01_00000000;  // lw $t1, 0($0)
    IMemory[7] = 16'b1000_00_10_00000010;  // lw $t2, 2($0)
    IMemory[8] = 16'b0100_10_10_10_000000;  // nor $t2, $t2, $t2 (sub $3, $1, $2 in two's complement)
    IMemory[9] = 16'b0111_10_10_00000001;  // addi $t2, $t2, 1
    IMemory[10] = 16'b0000_01_10_11_000000;  // add $t3, $t1, $t2

    // Data
    DMemory [0] = 16'd5; // swap the cells and see how the simulation output changes
    DMemory [1] = 16'd7;

  end
  initial PC = 0;
  assign IR = IMemory[PC>>1];
  assign SignExtend = {{8{IR[7]}},IR[7:0]}; // sign extension
  RegisterFile rf (IR[11:10],IR[9:8],WR,WD,RegWrite,A,RD2,clock);
  ALU pc_incrementer (PCplus2, ignored, ignored, PC, 16'd2, 4'b0010);
  ALU execution_unit (ALUOut, Zero, ignored, A, B, ALUctl);
  ALU branch_unit (Target, ignored, ignored, PCplus2, SignExtend<<1, 4'd2);
  MainControl MainCtr (IR[15:12],{RegDst,ALUSrc,MemtoReg,RegWrite,MemWrite,BEQ,BNE,ALUctl});
  
  mux_2x2 muxReg (WR, {IR[7:6], IR[9:8]}, RegDst);
  mux_2x16 muxWriteReg (WD,{DMemory[ALUOut>>1], ALUOut}, MemtoReg);
  mux_2x16 muxData (B, {SignExtend, RD2}, ALUSrc);
  mux_2x16 muxBranch (NextPC, {Target, PCplus2}, BEQ && Zero || BNE && ~Zero);

  always @(negedge clock) begin
    PC <= NextPC;
    if (MemWrite) DMemory[ALUOut>>1] <= RD2;
  end
endmodule

// Main Control Unit
module MainControl (Op, Control);
  // Inputs:
  input [3:0] Op;  // 4-bit opcode from instruction field

  // Outputs:
  output reg [10:0] Control; // Control signals for CPU execution
  // Format: {RegDst,ALUSrc,MemtoReg,RegWrite,MemWrite,BEQ,BNE,ALUctl[3:0]}

  always @(Op)
    case (Op)
      // R-type instructions
      4'b0000: Control = 11'b1_0_0_1_0_0_0_0010;  // add
      4'b0001: Control = 11'b1_0_0_1_0_0_0_0110;  // sub
      4'b0010: Control = 11'b1_0_0_1_0_0_0_0000;  // and
      4'b0011: Control = 11'b1_0_0_1_0_0_0_0001;  // or
      4'b0100: Control = 11'b1_0_0_1_0_0_0_1100;  // nor
      4'b0101: Control = 11'b1_0_0_1_0_0_0_1101;  // nand
      4'b0110: Control = 11'b1_0_0_1_0_0_0_0111;  // slt

      // I-type instructions
      4'b0111: Control = 11'b0_1_0_1_0_0_0_0010;  // addi
      4'b1000: Control = 11'b0_1_1_1_0_0_0_0010;  // lw
      4'b1001: Control = 11'b0_1_0_0_1_0_0_0010;  // sw
      4'b1010: Control = 11'b0_0_0_0_0_1_0_0110;  // beq
      4'b1011: Control = 11'b0_0_0_0_0_0_1_0110;  // bne
    endcase
endmodule

// Register File
module RegisterFile (readAddr1, readAddr2, writeAddr, writeData, writeEnable, readData1, readData2, clock);
  // Inputs
  input [1:0] readAddr1, readAddr2; // Addresses for reading two registers
  input [1:0] writeAddr;            // Address for writing to a register
  input [15:0] writeData;           // Data to be written
  input writeEnable;                // Control signal to enable writing
  input clock;                      // System clock for synchronous writes

  // Outputs
  output [15:0] readData1, readData2; // Data read from the specified registers

  reg [15:0] registerBank[0:3];     // Array of four 16-bit registers

  // Combinational read logic
  assign readData1 = registerBank[readAddr1];
  assign readData2 = registerBank[readAddr2];

  // Initialize register $0 to be a constant zero
  initial registerBank[0] = 0;

  // Synchronous write logic
  always @(negedge clock)
    if (writeEnable == 1 && writeAddr != 0) // Write only if enabled and not to register $0
      registerBank[writeAddr] <= writeData;
endmodule

// 16-bit Arithmetic Logic Unit
module ALU(r, zero, overflow, a, b, s);
  input [15:0] a, b;
  input [3:0] s;
  output [15:0] r;
  output zero, overflow;

  wire set;
  ALU1   alu0  (r[0],  co0,  a[0],  b[0],  set,  s, s[2]),
         alu1  (r[1],  co1,  a[1],  b[1],  1'b0, s, co0),
         alu2  (r[2],  co2,  a[2],  b[2],  1'b0, s, co1),
         alu3  (r[3],  co3,  a[3],  b[3],  1'b0, s, co2),
         alu4  (r[4],  co4,  a[4],  b[4],  1'b0, s, co3),
         alu5  (r[5],  co5,  a[5],  b[5],  1'b0, s, co4),
         alu6  (r[6],  co6,  a[6],  b[6],  1'b0, s, co5),
         alu7  (r[7],  co7,  a[7],  b[7],  1'b0, s, co6),
         alu8  (r[8],  co8,  a[8],  b[8],  1'b0, s, co7),
         alu9  (r[9],  co9,  a[9],  b[9],  1'b0, s, co8),
         alu10 (r[10], co10, a[10], b[10], 1'b0, s, co9),
         alu11 (r[11], co11, a[11], b[11], 1'b0, s, co10),
         alu12 (r[12], co12, a[12], b[12], 1'b0, s, co11),
         alu13 (r[13], co13, a[13], b[13], 1'b0, s, co12),
         alu14 (r[14], co14, a[14], b[14], 1'b0, s, co13);
  ALUmsb alu15 (r[15], set, overflow, a[15], b[15], 1'b0, s, co14);

  nor no1 (zero, r);
endmodule

// ALU subsection for all bits other than most significant bit
module ALU1(r, co, a, b, less, s, ci);
  input a, b, less, ci;
  input [3:0] s;
  output r, co;

  not n1 (na, a),
      n2 (nb, b);

  mux_2x1 inA (A, {na, a}, s[3]),
          inB (B, {nb, b}, s[2]);

  and a1 (r0, A, B);
  or o1 (r1, A, B);
  fulladder fa1 (co, r2, A, B, ci);

  mux_4x1 s1 (r, {less, r2, r1, r0}, s[1:0]);
endmodule

// ALU subsection for most significant bit
module ALUmsb(r, set, of, a, b, less, s, ci);
  input a, b, less, ci;
  input [3:0] s;
  output r, set, of;

  not n1 (na, a),
      n2 (nb, b);

  mux_2x1 inA (A, {na, a}, s[3]),
          inB (B, {nb, b}, s[2]);

  and a1 (r0, A, B);
  or o1 (r1, A, B);
  fulladder fa1 (co, set, A, B, ci);

  mux_4x1 s1 (r, {less, set, r1, r0}, s[1:0]);

  xor xo1 (of0, ci, co);
  and a3 (of, of0, s[1]);
endmodule

// 2x16 multiplexer
module mux_2x16(out, in, select);
  input [31:0] in;
  input select;
  output [15:0] out;
  mux_2x2 mux0 (out[1:0],   {in[17:16], in[1:0]},   select),
          mux1 (out[3:2],   {in[19:18], in[3:2]},   select),
          mux2 (out[5:4],   {in[21:20], in[5:4]},   select),
          mux3 (out[7:6],   {in[23:22], in[7:6]},   select),
          mux4 (out[9:8],   {in[25:24], in[9:8]},   select),
          mux5 (out[11:10], {in[27:26], in[11:10]}, select),
          mux6 (out[13:12], {in[29:28], in[13:12]}, select),
          mux7 (out[15:14], {in[31:30], in[15:14]}, select);
endmodule

// 2x2 multiplexer
module mux_2x2(out, in, select);
  input [3:0] in;
  input select;
  output [1:0] out;
  mux_2x1 muxLow  (out[0], {in[2], in[0]}, select),
          muxHigh (out[1], {in[3], in[1]}, select);
endmodule

// 2x1 multiplexer
module mux_2x1(out, in, select);
  input [1:0] in;
  input select;
  output out;
  wire a, b, selectprime;
  not n1 (selectprime, select);
  and a1 (a, in[0], selectprime);
  and a2 (b, in[1], select);
  or o1 (out, a, b);
endmodule

// 4x1 multiplexer
module mux_4x1(out, in, select);
  input [3:0] in;
  input [1:0] select;
  output out;

  not n1 (selectprime, select[1]);

  wire [1:0] work;
  mux_2x1 low (work[0], in[1:0], select[0]),
          high (work[1], in[3:2], select[0]),
          comb (out, work, select[1]);
endmodule

// 1-bit full adder
module fulladder(co, s, x, y, ci);
  input x, y, ci;
  output s, co;
  halfadder hadd1 (c1, s1, x, y),
            hadd2 (c2, s, s1, ci);
  or o1 (co, c1, c2);
endmodule

// 1-bit half adder
module halfadder(c, s, x, y);
  input x, y;
  output c, s;
  and a0 (c, x, y);
  not n0 (nc, c);
  or o0 (a, x, y);
  and a1 (s, a, nc);
endmodule

// Test module
module test ();
  reg clock;
  wire signed [15:0] WD,IR,PC;
  CPU test_cpu(clock,WD,IR,PC);
  always #1 clock = ~clock;
  initial begin
    $display ("PC  IR                                WD");
    $monitor ("%2d  %b %2d (%b)",PC,IR,WD,WD);
    clock = 1;
    #20 $finish;
  end
endmodule
